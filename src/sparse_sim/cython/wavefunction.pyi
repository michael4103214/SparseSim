from __future__ import annotations
from typing import TYPE_CHECKING, Any, Dict, List, Set

if TYPE_CHECKING:
    from .pauli import PauliString, PauliSum


class SlaterDeterminant:
    def __init__(self, N: int, coef: complex, orbitals: List[int]) -> None: ...
    def __reduce__(self) -> Any: ...
    def __str__(self) -> str: ...
    def adjoint(self) -> SlaterDeterminant: ...
    @property
    def N(self) -> int: ...
    @property
    def coef(self) -> complex: ...
    @property
    def orbitals(self) -> List[int]: ...
    @property
    def encoding(self) -> int: ...
    def __add__(self, right: SlaterDeterminant) -> Wavefunction: ...
    def __rmul__(self, left: complex) -> SlaterDeterminant: ...


class Wavefunction:
    def __init__(self, N: int, cutoff: float = 1e-8) -> None: ...
    def __str__(self) -> str: ...
    def norm(self) -> float: ...
    def append_slater_determinant(
        self, sdet: SlaterDeterminant) -> Wavefunction: ...

    def adjoint(self) -> Wavefunction: ...
    def remove_global_phase(self) -> Wavefunction: ...
    def remove_near_zero_terms(self, cutoff: float) -> Wavefunction: ...
    @property
    def s(self) -> Any: ...
    @property
    def N(self) -> int: ...
    # algebra
    def __mul__(self, right: Wavefunction) -> complex: ...
    def __rmul__(self, left: complex | PauliString |
                 PauliSum) -> Wavefunction: ...

    def __add__(self, right: SlaterDeterminant) -> Wavefunction: ...

    def slater_determinant_scalar_multiplication(
        sdet: SlaterDeterminant, scalar: complex) -> SlaterDeterminant: ...


def wavefunction_scalar_multiplication(
    wfn: Wavefunction, scalar: complex) -> Wavefunction: ...


def wavefunction_multiplication(
    bra: Wavefunction, ket: Wavefunction) -> complex: ...


def wavefunction_pauli_string_multiplication(
    pString: PauliString, wfn: Wavefunction) -> Wavefunction: ...


def wavefunction_pauli_sum_multiplication(
    pSum: PauliSum, wfn: Wavefunction) -> Wavefunction: ...


def wavefunction_pauli_string_evolution(
    pString: PauliString, wfn: Wavefunction, epsilon: complex) -> Wavefunction: ...


def wavefunction_pauli_sum_evolution(
    pSum: PauliSum, wfn: Wavefunction, epsilon: complex) -> Wavefunction: ...


def wavefunction_perform_tomography(
    wfn: Wavefunction, measurements: Set[str]) -> dict: ...


def wavefunction_to_probability_distribution(
    wfn: Wavefunction) -> Dict[str, float]: ...
