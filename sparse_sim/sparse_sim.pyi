from typing import List, Set, Any


class SlaterDeterminant:
    def __init__(self, N: int, coef: complex, orbitals: List[int]): ...
    def __reduce__(self) -> Any: ...
    def __str__(self) -> str: ...
    def adjoint(self) -> "SlaterDeterminant": ...
    @property
    def N(self) -> int: ...
    @property
    def coef(self) -> complex: ...
    @property
    def orbitals(self) -> List[int]: ...
    @property
    def encoding(self) -> int: ...
    def __add__(self, right: "SlaterDeterminant") -> Any: ...
    def __rmul__(self, left: complex) -> "SlaterDeterminant": ...


class Wavefunction:
    def __init__(self, N: int): ...
    def __str__(self) -> str: ...
    def norm(self) -> float: ...
    def append_slater_determinant(
        self, sdet: SlaterDeterminant) -> "Wavefunction": ...

    def adjoint(self) -> "Wavefunction": ...
    def remove_global_phase(self) -> "Wavefunction": ...
    def remove_near_zero_terms(self, cutoff: float) -> "Wavefunction": ...
    @property
    def s(self) -> int: ...
    @property
    def N(self) -> int: ...
    def __mul__(self, right: Any) -> Any: ...
    def __rmul__(self, left: complex) -> "Wavefunction": ...
    def __add__(self, right: SlaterDeterminant) -> "Wavefunction": ...


class PauliString:
    def __init__(self, N: int, coef: complex, paulis: List[str]): ...
    def __str__(self) -> str: ...
    def adjoint(self) -> "PauliString": ...
    @property
    def N(self) -> int: ...
    @property
    def coef(self) -> complex: ...
    @property
    def string(self) -> str: ...
    @property
    def matrix(self) -> Any: ...
    def __mul__(self, right: Any) -> Any: ...
    def __rmul__(self, left: complex) -> "PauliString": ...
    def __add__(self, right: "PauliString") -> "PauliSum": ...


class PauliSum:
    def __init__(self, N: int): ...
    def __str__(self) -> str: ...
    def append_pauli_string(self, pString: PauliString) -> None: ...
    def adjoint(self) -> "PauliSum": ...
    def get_pauli_strings(self) -> List[PauliString]: ...
    @property
    def p(self) -> int: ...
    @property
    def N(self) -> int: ...
    @property
    def matrix(self) -> Any: ...
    def __mul__(self, right: Any) -> Any: ...
    def __rmul__(self, left: complex) -> "PauliSum": ...
    def __add__(self, right: "PauliSum") -> "PauliSum": ...

# Standalone functions


def slater_determinant_scalar_multiplication(
    sdet: SlaterDeterminant, scalar: complex) -> SlaterDeterminant: ...


def wavefunction_scalar_multiplication(
    wfn: Wavefunction, scalar: complex) -> Wavefunction: ...


def wavefunction_multiplication(
    bra: Wavefunction, ket: Wavefunction) -> complex: ...


def wavefunction_pauli_string_multiplication(
    pString: PauliString, wfn: Wavefunction) -> Wavefunction: ...


def wavefunction_pauli_sum_multiplication(
    pSum: PauliSum, wfn: Wavefunction) -> Wavefunction: ...


def wavefunction_pauli_string_evolution(
    pString: PauliString, wfn: Wavefunction, epsilon: complex) -> Wavefunction: ...


def wavefunction_pauli_sum_evolution(
    pSum: PauliSum, wfn: Wavefunction, epsilon: complex) -> Wavefunction: ...


def pauli_string_scalar_multiplication(
    pString: PauliString, scalar: complex) -> PauliString: ...


def pauli_string_multiplication(
    left: PauliString, right: PauliString) -> PauliString: ...
def pauli_sum_scalar_multiplication(
    pSum: PauliSum, scalar: complex) -> PauliSum: ...


def pauli_sum_multiplication(left: PauliSum, right: PauliSum) -> PauliSum: ...
def pauli_sum_collect_measurements(pSum: PauliSum) -> Set[str]: ...


def wavefunction_perform_tomography(
    wfn: Wavefunction, measurements: Set[str]) -> dict: ...
def pauli_sum_evaluate_expectation(
    pSum: PauliSum, tomography: dict) -> complex: ...


def pauli_sum_addition(left: PauliSum, right: PauliSum) -> PauliSum: ...


def wavefunction_to_probability_distribution(wfn: Wavefunction) -> dict: ...
